
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=utf-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Foreword/index.rst:4
msgid "Foreword"
msgstr "前言"
#: ../../source/SpinalHDL/Foreword/index.rst:6
msgid "Preliminary notes:"
msgstr "初步说明："
#: ../../source/SpinalHDL/Foreword/index.rst:8
msgid ""
"All the following statements will be about describing digital hardware. "
"Verification is another tasty topic."
msgstr "以下所有陈述都是关于描述数字硬件的。验证是另一个有趣的话题。"
#: ../../source/SpinalHDL/Foreword/index.rst:10
msgid ""
"For conciseness, let's assume that SystemVerilog is a recent revision of "
"Verilog."
msgstr "为了简洁起见，我们假设 SystemVerilog 是 Verilog 的最新版本。"
#: ../../source/SpinalHDL/Foreword/index.rst:12
msgid ""
"When reading this, we should not underestimate how much our attachment for "
"our favourite HDL will bias our judgement."
msgstr "当阅读本文时，我们不应该低估我们对我们最喜欢的 HDL 的依恋会在多大程度上影响我们的判断。"
#: ../../source/SpinalHDL/Foreword/index.rst:17
msgid "Why moving away from traditional HDL"
msgstr "为什么要放弃传统的 HDL"
#: ../../source/SpinalHDL/Foreword/index.rst:20
msgid "VHDL/Verilog aren't Hardware Description Languages"
msgstr "VHDL/Verilog 不是硬件描述语言"
#: ../../source/SpinalHDL/Foreword/index.rst:22
msgid ""
"Those languages are event driven languages created initially for "
"simulation/documentation purposes. Only in a second time they were used as "
"inputs languages for synthesis tools. Which explain the roots of a lot of "
"the following points."
msgstr "这些语言是最初为模拟/文档目的而创建的事件驱动语言。仅在第二次，它们才被用作综合工具的输入语言。其中解释了很多以下几点的根源。"
#: ../../source/SpinalHDL/Foreword/index.rst:29
msgid "Event driven paradigm doesn't make any sense for RTL"
msgstr "事件驱动范例对于 RTL 没有任何意义"
#: ../../source/SpinalHDL/Foreword/index.rst:31
msgid ""
"When you think about it, describing digital hardware (RTL) by using "
"process/always blocks doesn't make any practical senses. Why do we have to "
"worry about a sensitivity list? Why do we have to split our design between "
"processes/always blocks of different natures (combinatorial logic / register"
" without reset / register with async reset)?"
msgstr ""
"仔细想想，使用 process/always 块描述数字硬件 (RTL) "
"没有任何实际意义。为什么我们必须担心敏感列表？为什么我们必须在不同性质的进程/始终块之间分割我们的设计（组合逻辑/不带复位的寄存器/带异步复位的寄存器）？"
#: ../../source/SpinalHDL/Foreword/index.rst:37
msgid "For instance, to implement this:"
msgstr "例如，要实现这个："
#: ../../source/SpinalHDL/Foreword/index.rst:42
msgid "Using VHDL processes you write this:"
msgstr "使用 VHDL 流程，您可以编写以下内容："
#: ../../source/SpinalHDL/Foreword/index.rst:78
msgid "Using SpinalHDL you write this:"
msgstr "使用 SpinalHDL 你可以这样写："
#: ../../source/SpinalHDL/Foreword/index.rst:93
msgid ""
"As for everything, you can get used to this event driven semantic, until you"
" taste something better."
msgstr "至于一切，你可以习惯这种事件驱动的语义，直到你尝到更好的东西。"
#: ../../source/SpinalHDL/Foreword/index.rst:98
msgid "Recent revisions of VHDL and Verilog aren't usable"
msgstr "VHDL 和 Verilog 的最新版本不可用"
#: ../../source/SpinalHDL/Foreword/index.rst:100
msgid ""
"The EDA industry is really slow to implement VHDL 2008 and SystemVerilog "
"synthesis capabilities in their tools. Additionally, when it's done, it "
"appear that only a constraining subset of the language is implemented (not "
"talking about simulation features). It result that using any interesting "
"feature of those language revision isn't safe as:"
msgstr ""
"EDA 行业在其工具中实现 VHDL 2008 和 SystemVerilog "
"综合功能的速度确实很慢。此外，当它完成时，似乎只实现了该语言的一个约束子集（不谈论模拟功能）。结果是使用这些语言修订版的任何有趣功能都不安全，因为："
#: ../../source/SpinalHDL/Foreword/index.rst:106
msgid "It will probably make your code incompatible with many EDA tools."
msgstr "它可能会使您的代码与许多 EDA 工具不兼容。"
#: ../../source/SpinalHDL/Foreword/index.rst:107
msgid ""
"Other companies will likely not accept your IP as their flow isn't ready for"
" it."
msgstr "其他公司可能不会接受您的 IP，因为他们的流程尚未准备好。"
#: ../../source/SpinalHDL/Foreword/index.rst:110
msgid ""
"Anyway, those revisions don't change the heart of those HDL issues: they are"
" based on a event driven paradigm which doesn't make sense to describe "
"digital hardware."
msgstr "无论如何，这些修订并没有改变 HDL 问题的核心：它们基于事件驱动范例，这对于描述数字硬件没有意义。"
#: ../../source/SpinalHDL/Foreword/index.rst:116
msgid ""
"VHDL records, Verilog struct are broken (SystemVerilog is good on this, if "
"you can use it)"
msgstr "VHDL记录、Verilog结构被破坏（SystemVerilog在这方面很好，如果你可以使用它）"
#: ../../source/SpinalHDL/Foreword/index.rst:118
msgid ""
"You can't use them to define an interface, because you can't define their "
"internal signal directions. Even worst, you can't give them construction "
"parameters! So, define your RGB record/struct once, and hope you never have "
"to use it with bigger/smaller color channels..."
msgstr ""
"您不能使用它们来定义接口，因为您无法定义它们的内部信号方向。更糟糕的是，您无法向他们提供构造参数！因此，定义一次 RGB "
"记录/结构，并希望您永远不必将其与更大/更小的颜色通道一起使用......"
#: ../../source/SpinalHDL/Foreword/index.rst:123
msgid ""
"Also a fancy thing with VHDL is the fact that if you want to add an array of"
" something into a component entity, you have to define the type of this "
"array into a package... Which can't be parameterized..."
msgstr "VHDL 的另一个奇特之处是，如果您想将某个数组添加到组件实体中，则必须将该数组的类型定义到包中...这不能参数化..."
#: ../../source/SpinalHDL/Foreword/index.rst:127
msgid "For instance, below is a SpinalHDL APB3 bus definition:"
msgstr "例如，下面是 SpinalHDL APB3 总线定义："
#: ../../source/SpinalHDL/Foreword/index.rst:159
msgid ""
"Then about the VHDL 2008 partial solution and the SystemVerilog "
"interface/modport, lucky you are if your EDA tools / company flow / company "
"policy allow you to use them."
msgstr ""
"然后关于VHDL "
"2008部分解决方案和SystemVerilog接口/modport，如果您的EDA工具/公司流程/公司政策允许您使用它们，那么您很幸运。"
#: ../../source/SpinalHDL/Foreword/index.rst:165
msgid "VHDL and Verilog are so verbose"
msgstr "VHDL 和 Verilog 太冗长了"
#: ../../source/SpinalHDL/Foreword/index.rst:167
msgid ""
"Really, with VHDL and Verilog, when it starts to be about component "
"instantiation interconnection, the copy-paste god has to be invoked."
msgstr "确实，对于VHDL和Verilog，当它开始涉及组件实例化互连时，必须调用复制粘贴之神。"
#: ../../source/SpinalHDL/Foreword/index.rst:170
msgid ""
"To understand it more deeply, below is a SpinalHDL example performing some "
"peripherals instantiation and adding the APB3 decoder required to access "
"them."
msgstr "为了更深入地理解它，下面是一个 SpinalHDL 示例，该示例执行一些外设实例化并添加访问它们所需的 APB3 解码器。"
#: ../../source/SpinalHDL/Foreword/index.rst:203
msgid ""
"Done. That's all. You don't have to bind each signal one by one when you "
"instantiate a module/component because you can access their interfaces in a "
"object-oriented manner."
msgstr "完毕。就这样。当你实例化一个模块/组件时，你不必一一绑定每个信号，因为你可以以面向对象的方式访问它们的接口。"
#: ../../source/SpinalHDL/Foreword/index.rst:207
msgid ""
"Also about VHDL/Verilog struct/records, we can say that they are really "
"dirty tricks, without true parameterization and reusability capabilities, "
"trying to hide the fact that those languages were poorly designed."
msgstr ""
"另外，关于 VHDL/Verilog 结构/记录，我们可以说它们确实是肮脏的把戏，没有真正的参数化和可重用性功能，试图掩盖这些语言设计不佳的事实。"
#: ../../source/SpinalHDL/Foreword/index.rst:213
msgid "Meta Hardware Description capabilities"
msgstr "元硬件描述功能"
#: ../../source/SpinalHDL/Foreword/index.rst:215
msgid ""
"Basically VHDL and Verilog provide some elaboration tools which aren't "
"directly mapped into hardware as loops / generate statements / macro / "
"function / procedure / task. But that's all."
msgstr ""
"基本上，VHDL 和 Verilog 提供了一些详细工具，这些工具不会直接映射到硬件中，如循环/生成语句/宏/函数/过程/任务。但仅此而已。"
#: ../../source/SpinalHDL/Foreword/index.rst:219
msgid ""
"And even then, they are really limited. For instance one can't define "
"process/always/component/module blocks into a task/procedure. It is really a"
" bottleneck for many fancy things."
msgstr "即便如此，它们的作用也确实有限。例如，无法将流程/始终/组件/模块块定义到任务/过程中。这确实是许多花哨事物的瓶颈。"
#: ../../source/SpinalHDL/Foreword/index.rst:223
msgid ""
"With SpinalHDL you can call a user-defined task/procedure on a bus like "
"that: ``myHandshakeBus.queue(depth=64)``. Below is some code including the "
"definition."
msgstr ""
"使用 SpinalHDL，您可以在总线上调用用户定义的任务/过程，如下所示：``myHandshakeBus.queue（深度 = "
"64）``。下面是一些包含定义的代码。"
#: ../../source/SpinalHDL/Foreword/index.rst:249
msgid ""
"Let's see further, imagine you want to define a state machine. With "
"VHDL/Verilog you have to write a lot of raw code with some switch statements"
" to do it. You can't define the notion of \"StateMachine\", which would give"
" you a nice syntax to define each state. Else you can use a third-party tool"
" to draw your state machine and then generate your VHDL/Verilog equivalent "
"code..."
msgstr ""
"让我们进一步看一下，假设您想要定义一个状态机。使用 VHDL/Verilog，您必须编写大量带有一些 switch "
"语句的原始代码才能完成此操作。您无法定义“StateMachine”的概念，这将为您提供一个很好的语法来定义每个状态。否则，您可以使用第三方工具来绘制状态机，然后生成"
" VHDL/Verilog 等效代码..."
#: ../../source/SpinalHDL/Foreword/index.rst:255
msgid ""
"Meta-hardware description capabilities of SpinalHDL enable you to define "
"your own tools which then allow you to define things in abstracts ways, as "
"for state machines."
msgstr "SpinalHDL 的元硬件描述功能使您能够定义自己的工具，然后允许您以抽象方式定义事物，例如状态机。"
#: ../../source/SpinalHDL/Foreword/index.rst:259
msgid ""
"Below is an simple example of the usage of a state machine abstraction "
"defined on the top of SpinalHDL:"
msgstr "下面是一个使用 SpinalHDL 顶部定义的状态机抽象的简单示例："
#: ../../source/SpinalHDL/Foreword/index.rst:290
msgid ""
"Imagine you want to generate the instruction decoding of your CPU. It could "
"require some fancy elaboration time algorithms to generate the less logic "
"possible. But in VHDL/Verilog, your only option to do this kind of things is"
" to write a script which generates the ``.vhd`` and ``.v`` that you want."
msgstr ""
"想象一下您想要生成 CPU 的指令解码。它可能需要一些奇特的阐述时间算法来生成尽可能少的逻辑。但在 VHDL/Verilog "
"中，执行此类操作的唯一选择是编写一个脚本来生成您想要的“.vhd”和“.v”。"
#: ../../source/SpinalHDL/Foreword/index.rst:295
msgid ""
"There is really much to say about meta-hardware description, but the only "
"true way to understand it and get its real taste is to experiment it. The "
"goal with it is to stop playing with wires and gates, to start taking some "
"distance with that low level stuff, to think reusable."
msgstr ""
"关于元硬件描述确实有很多话要说，但理解它并获得其真正味道的唯一真正方法就是进行实验。它的目标是停止使用电线和门，开始与那些低级的东西保持一定的距离，并考虑可重用。"
