
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=utf-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Structuring/naming.rst:5
msgid "Preserving names"
msgstr "保留名字"
#: ../../source/SpinalHDL/Structuring/naming.rst:8
msgid "Introduction"
msgstr "介绍"
#: ../../source/SpinalHDL/Structuring/naming.rst:10
msgid ""
"This page will describe how SpinalHDL propagate names from the scala code to"
" the generated hardware. Knowing them should enable you to preserve those "
"names as much as possible to generate understandable netlists."
msgstr ""
"本页将描述 SpinalHDL 如何将名称从 scala 代码传播到生成的硬件。了解它们应该使您能够尽可能保留这些名称，以生成可理解的网表。"
#: ../../source/SpinalHDL/Structuring/naming.rst:13
msgid "Nameable base class"
msgstr "可命名基类"
#: ../../source/SpinalHDL/Structuring/naming.rst:15
msgid ""
"All the things which can be named in SpinalHDL extends the Nameable base "
"class which."
msgstr "所有可以在 SpinalHDL 中命名的事物都扩展了 Nameable 基类。"
#: ../../source/SpinalHDL/Structuring/naming.rst:17
msgid "So in practice, the following classes extends Nameable :"
msgstr "因此在实践中，以下类扩展了 Nameable ："
#: ../../source/SpinalHDL/Structuring/naming.rst:19
msgid "Component"
msgstr "成分"
#: ../../source/SpinalHDL/Structuring/naming.rst:20
msgid "Area"
msgstr "区域"
#: ../../source/SpinalHDL/Structuring/naming.rst:21
msgid "Data (UInt, SInt, Bundle, ...)"
msgstr "数据（UInt、SInt、捆绑包……）"
#: ../../source/SpinalHDL/Structuring/naming.rst:24
msgid "There is a few example of that Nameable API"
msgstr "有一些可命名 API 的示例"
#: ../../source/SpinalHDL/Structuring/naming.rst:35
msgid "Will generation :"
msgstr "遗嘱代："
#: ../../source/SpinalHDL/Structuring/naming.rst:47
msgid ""
"In general, you don't realy need to access that API, unless you want to do "
"tricky stuff for debug reasons or for elaboration purposes."
msgstr "一般来说，您实际上并不需要访问该 API，除非您出于调试原因或出于详细说明的目的想要执行一些棘手的操作。"
#: ../../source/SpinalHDL/Structuring/naming.rst:50
msgid "Name extraction from Scala"
msgstr "从 Scala 中提取名称"
#: ../../source/SpinalHDL/Structuring/naming.rst:52
msgid ""
"First, since version 1.4.0, SpinalHDL use a scala compiler plugin which can "
"provide a call back each time a new val is defined during the construction "
"of an class."
msgstr "首先，从 1.4.0 版本开始，SpinalHDL 使用 scala 编译器插件，该插件可以在类构造期间每次定义新 val 时提供回调。"
#: ../../source/SpinalHDL/Structuring/naming.rst:54
msgid ""
"There is a example showing more or less how SpinalHDL itself is implemented "
":"
msgstr "有一个示例或多或少地展示了 SpinalHDL 本身是如何实现的："
#: ../../source/SpinalHDL/Structuring/naming.rst:84
msgid ""
"Using that ValCallback \"introspection\" feature, SpinalHDL's Component "
"classes are able to be aware of their content and its name."
msgstr "使用 ValCallback“内省”功能，SpinalHDL 的组件类能够了解其内容及其名称。"
#: ../../source/SpinalHDL/Structuring/naming.rst:86
msgid ""
"But this also mean that if you want something to get a name, and you only "
"rely on this automatic naming feature, the reference to your Data (UInt, "
"SInt, ...) instances should be stored somewhere in a Component val."
msgstr ""
"但这也意味着，如果您希望某些东西获得名称，并且仅依赖于此自动命名功能，则对 Data (UInt、SInt、...) 实例的引用应存储在 "
"Component val 中的某个位置。"
#: ../../source/SpinalHDL/Structuring/naming.rst:88
msgid "For instance :"
msgstr "例如 ："
#: ../../source/SpinalHDL/Structuring/naming.rst:104
#: ../../source/SpinalHDL/Structuring/naming.rst:200
#: ../../source/SpinalHDL/Structuring/naming.rst:237
msgid "Will generate :"
msgstr "将生成："
#: ../../source/SpinalHDL/Structuring/naming.rst:119
msgid "Area in a Component"
msgstr "组件中的区域"
#: ../../source/SpinalHDL/Structuring/naming.rst:121
msgid ""
"One important aspect in the naming system is that you can define new "
"namespaces inside components and manipulate"
msgstr "命名系统的一个重要方面是您可以在组件内定义新的名称空间并进行操作"
#: ../../source/SpinalHDL/Structuring/naming.rst:123
msgid "For instance via Area :"
msgstr "例如通过 Area ："
#: ../../source/SpinalHDL/Structuring/naming.rst:134
#: ../../source/SpinalHDL/Structuring/naming.rst:300
#: ../../source/SpinalHDL/Structuring/naming.rst:385
#: ../../source/SpinalHDL/Structuring/naming.rst:417
#: ../../source/SpinalHDL/Structuring/naming.rst:466
#: ../../source/SpinalHDL/Structuring/naming.rst:520
msgid "Will generate"
msgstr "会生成"
#: ../../source/SpinalHDL/Structuring/naming.rst:149
msgid "Area in a function"
msgstr "函数中的面积"
#: ../../source/SpinalHDL/Structuring/naming.rst:151
msgid ""
"You can also define function which will create new Area which will provide a"
" namespace for all its content :"
msgstr "您还可以定义将创建新区域的函数，该区域将为其所有内容提供命名空间："
#: ../../source/SpinalHDL/Structuring/naming.rst:167
msgid "Which will generate :"
msgstr "这将生成："
#: ../../source/SpinalHDL/Structuring/naming.rst:183
msgid "Composite in a function"
msgstr "复合在一个函数中"
#: ../../source/SpinalHDL/Structuring/naming.rst:185
msgid ""
"Added in SpinalHDL 1.5.0, Composite which allow you to create a scope which "
"will use as prefix another Nameable:"
msgstr "SpinalHDL 1.5.0 中添加了 Composite，它允许您创建一个范围，该范围将用作另一个 Nameable 的前缀："
#: ../../source/SpinalHDL/Structuring/naming.rst:216
msgid "Composite chains"
msgstr "复合链条"
#: ../../source/SpinalHDL/Structuring/naming.rst:218
msgid "You can also chain composites :"
msgstr "您还可以链接复合材料："
#: ../../source/SpinalHDL/Structuring/naming.rst:255
msgid "Composite in a Bundle's function"
msgstr "复合在一个Bundle的函数中"
#: ../../source/SpinalHDL/Structuring/naming.rst:258
msgid ""
"This behaviour can be very useful when implementing Bundles utilities. For "
"instance in the spinal.lib.Stream class is defined the following :"
msgstr "在实现 Bundles 实用程序时，此行为非常有用。例如，在 spin.lib.Stream 类中定义如下："
#: ../../source/SpinalHDL/Structuring/naming.rst:290
msgid "Which allow nested calls while preserving the names :"
msgstr "允许嵌套调用，同时保留名称："
#: ../../source/SpinalHDL/Structuring/naming.rst:365
msgid "Unamed signal handling"
msgstr "未命名信号处理"
#: ../../source/SpinalHDL/Structuring/naming.rst:367
msgid ""
"Since 1.5.0, for signal which end up without name, SpinalHDL will find a "
"signal which is driven by that unamed signal and propagate its name. This "
"can produce useful results as long you don't have too large island of unamed"
" stuff."
msgstr ""
"从 1.5.0 开始，对于最终没有名称的信号，SpinalHDL "
"将找到由该未命名信号驱动的信号并传播其名称。只要您没有太多未命名的东西，这就可以产生有用的结果。"
#: ../../source/SpinalHDL/Structuring/naming.rst:369
msgid ""
"The name attributed to such unamed signal is : _zz_ + drivenSignal.getName()"
msgstr "这种未命名信号的名称是：_zz_ +drivenSignal.getName()"
#: ../../source/SpinalHDL/Structuring/naming.rst:371
msgid ""
"Note that this naming pattern is also used by the generation backend when "
"they need to breakup some specific expressions or long chain of expression "
"into multiple signals."
msgstr "请注意，当生成后端需要将某些特定表达式或长表达式链分解为多个信号时，也会使用此命名模式。"
#: ../../source/SpinalHDL/Structuring/naming.rst:374
msgid "Verilog expression splitting"
msgstr "Verilog 表达式分割"
#: ../../source/SpinalHDL/Structuring/naming.rst:376
msgid ""
"There is an instance of expressions (ex : the + operator) that SpinalHDL "
"need to express in dedicated signals to match the behaviour with the Scala "
"API :"
msgstr "SpinalHDL 需要在专用信号中表达一个表达式实例（例如：+ 运算符），以将行为与 Scala API 相匹配："
#: ../../source/SpinalHDL/Structuring/naming.rst:406
msgid "Verilog long expression splitting"
msgstr "Verilog 长表达式分割"
#: ../../source/SpinalHDL/Structuring/naming.rst:408
msgid ""
"There is a instance of how a very long expression chain will be splited up "
"by SpinalHDL :"
msgstr "有一个例子说明 SpinalHDL 如何分割很长的表达链："
#: ../../source/SpinalHDL/Structuring/naming.rst:447
msgid "When statement condition"
msgstr "When 语句条件"
#: ../../source/SpinalHDL/Structuring/naming.rst:449
msgid ""
"The `when(cond) { }` statements condition are generated into separated "
"signals named `when_` + fileName + line. A similar thing will also be done "
"for switch statements."
msgstr ""
"`when(cond) { }` 语句条件生成为名为 `when_` + fileName + line 的单独信号。 switch "
"语句也会做类似的事情。"
#: ../../source/SpinalHDL/Structuring/naming.rst:499
msgid "In last resort"
msgstr "最后一招"
#: ../../source/SpinalHDL/Structuring/naming.rst:501
msgid ""
"In last resort, if a signal has no name (anonymous signal), SpinalHDL will "
"seek for a named signal which is driven by the anonymous signal, and use it "
"as a name postfix :"
msgstr "最后，如果信号没有名称（匿名信号），SpinalHDL 将寻找由匿名信号驱动的命名信号，并将其用作名称后缀："
#: ../../source/SpinalHDL/Structuring/naming.rst:540
msgid ""
"This last resort naming skim isn't ideal in all cases, but can help out."
msgstr "最后的命名略读方法并不适合所有情况，但可以提供帮助。"
#: ../../source/SpinalHDL/Structuring/naming.rst:542
msgid ""
"Note that signal starting with a underscore aren't stored in the Verilator "
"waves (on purpose)"
msgstr "请注意，以下划线开头的信号不会存储在 Verilator 波形中（故意）"
