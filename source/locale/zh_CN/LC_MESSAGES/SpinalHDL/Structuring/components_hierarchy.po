
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=utf-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:4
msgid "Component and hierarchy"
msgstr "组件和层次结构"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:7
msgid "Introduction"
msgstr "介绍"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:9
msgid ""
"Like in VHDL and Verilog, you can define components that can be used to "
"build a design hierarchy. However, in SpinalHDL, you don't need to bind "
"their ports at instantiation:"
msgstr ""
"与 VHDL 和 Verilog 一样，您可以定义可用于构建设计层次结构的组件。但是，在 SpinalHDL 中，您不需要在实例化时绑定它们的端口："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst
msgid "``val io = new Bundle { ... }``"
msgstr "``val io = new Bundle { ... }``"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst
msgid ""
"Declaring external ports in a ``Bundle`` called ``io`` is recommended. If "
"you name your bundle ``io``, SpinalHDL will check that all of its elements "
"are defined as inputs or outputs."
msgstr "建议在名为“io”的“Bundle”中声明外部端口。如果您将包命名为“io”，SpinalHDL 将检查其所有元素是否定义为输入或输出。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst
msgid ""
"If it is better to your taste, you can use the ``Module`` syntax instead of "
"``Component`` (they are the same thing)"
msgstr "如果更适合您的口味，您可以使用“Module”语法而不是“Component”（它们是相同的东西）"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:48
msgid "Input / output definition"
msgstr "输入/输出定义"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:50
msgid "The syntax to define inputs and outputs is as follows:"
msgstr "定义输入和输出的语法如下："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:56
msgid "Syntax"
msgstr "句法"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:57
msgid "Description"
msgstr "描述"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:58
msgid "Return"
msgstr "返回"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:59
msgid "in Bool()/out Bool()"
msgstr "输入布尔()/输出布尔()"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:60
msgid "Create an input Bool/output Bool"
msgstr "创建输入 Bool/输出 Bool"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:61
msgid "Bool"
msgstr "布尔"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:62
msgid "in/out Bits/UInt/SInt[(x bits)]"
msgstr "输入/输出位/UInt/SInt[(x 位)]"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:63
msgid "Create an input/output of the corresponding type"
msgstr "创建相应类型的输入/输出"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:64
msgid "Bits/UInt/SInt"
msgstr "位/UInt/SInt"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:65
msgid "in/out(T)"
msgstr "输入/输出(T)"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:66
msgid ""
"For all other data types, you may have to add some brackets around it. "
"Sorry, this is a Scala limitation."
msgstr "对于所有其他数据类型，您可能需要在其周围添加一些括号。抱歉，这是 Scala 的限制。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:67
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:71
msgid "T"
msgstr "时间"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:68
msgid "master/slave(T)"
msgstr "主/从(T)"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:69
msgid ""
"This syntax is provided by the ``spinal.lib`` library (If you annotate your "
"object with the ``slave`` syntax, then import ``spinal.lib.slave`` instead)."
" T should extend ``IMasterSlave`` – Some documentation is available "
":ref:`here <interface_example_apb>`. You may not actually need the brackets,"
" so ``master T`` is fine as well."
msgstr ""
"此语法由``spinal.lib`` 库提供（如果您使用``slave`` 语法注释对象，则改为导入``spinal.lib.slave``）。 T "
"应该扩展``IMasterSlave`` - 一些文档可用:ref:`here "
"<interface_example_apb>`。您实际上可能不需要括号，因此“master T”也可以。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:74
msgid "There are some rules to follow with component interconnection:"
msgstr "组件互连需要遵循一些规则："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:77
msgid ""
"Components can only **read** output and input signals of child components."
msgstr "组件只能**读取**子组件的输出和输入信号。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:78
msgid "Components can read their own output port values (unlike in VHDL)."
msgstr "组件可以读取自己的输出端口值（与 VHDL 不同）。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:81
msgid ""
"If for some reason you need to read signals from far away in the hierarchy "
"(such as for debugging or temporal patches), you can do it by using the "
"value returned by ``some.where.else.theSignal.pull()``"
msgstr ""
"如果由于某种原因您需要从层次结构中较远的位置读取信号（例如用于调试或临时补丁），您可以使用“some.where.else.theSignal.pull()”返回的值来完成此操作"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:84
msgid "Pruned signals"
msgstr "修剪信号"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:86
msgid ""
"SpinalHDL will generate all the named signals and their depedencies, while "
"all the useless anonymous / zero width ones are removed from the RTL "
"generation."
msgstr "SpinalHDL 将生成所有命名信号及其依赖性，而所有无用的匿名/零宽度信号将从 RTL 生成中删除。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:88
msgid ""
"You can collect the list of all the removed ans useless signals via the "
"``printPruned`` and the ``printPrunedIo`` functions on the generated "
"``SpinalReport`` object:"
msgstr ""
"您可以通过生成的“SpinalReport”对象上的“printPruned”和“printPrunedIo”函数收集所有已删除的无用信号的列表："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:117
msgid "Parametrized Hardware (\"Generic\" in VHDL, \"Parameter\" in Verilog)"
msgstr "参数化硬件（VHDL 中的“通用”，Verilog 中的“参数”）"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:119
msgid ""
"If you want to parameterize your component, you can give parameters to the "
"constructor of the component as follows:"
msgstr "如果你想参数化你的组件，你可以将参数传递给组件的构造函数，如下所示："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:137
msgid ""
"If you have several parameters, it is a good practice to give a specific "
"configuration class as follows:"
msgstr "如果您有多个参数，最好给出一个特定的配置类，如下所示："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:150
msgid ""
"You can add functions inside the config, along with requirements on the "
"config attributes:"
msgstr "您可以在配置中添加功能以及对配置属性的要求："
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:163
msgid "Synthesized component names"
msgstr "合成的组件名称"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:165
msgid ""
"Within a module, each component has a name, called a \"partial name\". The "
"\"full\" name is built by joining every component's parent name with \"_\", "
"for example: ``io_clockDomain_reset``. You can use ``setName`` to replace "
"this convention with a custom name. This is especially useful when "
"interfacing with external components. The other methods are called "
"``getName``, ``setPartialName``, and ``getPartialName`` respectively."
msgstr ""
"在模块内，每个组件都有一个名称，称为“部分名称”。 "
"“完整”名称是通过将每个组件的父名称与“_”连接起来构建的，例如：``io_clockDomain_reset``。您可以使用“setName”将此约定替换为自定义名称。这在与外部组件连接时特别有用。其他方法分别称为“getName”、“setPartialName”和“getPartialName”。"
#: ../../source/SpinalHDL/Structuring/components_hierarchy.rst:171
msgid ""
"When synthesized, each module gets the name of the Scala class defining it. "
"You can override this as well with ``setDefinitionName``."
msgstr "综合时，每个模块都会获得定义它的 Scala 类的名称。您也可以使用“setDefinitionName”覆盖它。"
