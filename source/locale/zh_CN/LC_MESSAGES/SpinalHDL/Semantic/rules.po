
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=utf-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Semantic/rules.rst:3
msgid "Rules"
msgstr "规则"
#: ../../source/SpinalHDL/Semantic/rules.rst:6
msgid "Introduction"
msgstr "介绍"
#: ../../source/SpinalHDL/Semantic/rules.rst:8
msgid ""
"The semantics behind SpinalHDL are important to learn, so that you "
"understand what is really happening behind the scenes, and how to control "
"it."
msgstr "SpinalHDL 背后的语义很重要，这样您就可以了解幕后真正发生的事情以及如何控制它。"
#: ../../source/SpinalHDL/Semantic/rules.rst:10
msgid "These semantics are defined by multiple rules:"
msgstr "这些语义由多个规则定义："
#: ../../source/SpinalHDL/Semantic/rules.rst:12
msgid ""
"Signals and registers are operating concurrently with each other (parallel "
"behavioral, as in VHDL and Verilog)"
msgstr "信号和寄存器彼此同时运行（并行行为，如 VHDL 和 Verilog）"
#: ../../source/SpinalHDL/Semantic/rules.rst:13
msgid ""
"An assignment to a combinational signal is like expressing a rule which is "
"always true"
msgstr "对组合信号的赋值就像表达一条始终为真的规则"
#: ../../source/SpinalHDL/Semantic/rules.rst:14
msgid ""
"An assignment to a register is like expressing a rule which is applied on "
"each cycle of its clock domain"
msgstr "对寄存器的赋值就像表达一条应用于其时钟域的每个周期的规则"
#: ../../source/SpinalHDL/Semantic/rules.rst:15
msgid "For each signal, the last valid assignment wins"
msgstr "对于每个信号，最后一个有效的分配获胜"
#: ../../source/SpinalHDL/Semantic/rules.rst:16
msgid ""
"Each signal and register can be manipulated as an object during hardware "
"elaboration in a `OOP <https://en.wikipedia.org/wiki/Object-"
"oriented_programming>`_ manner"
msgstr ""
"每个信号和寄存器都可以在硬件精化期间以“OOP <https://en.wikipedia.org/wiki/Object-"
"oriented_programming>”方式作为对象进行操作"
#: ../../source/SpinalHDL/Semantic/rules.rst:19
msgid "Concurrency"
msgstr "并发性"
#: ../../source/SpinalHDL/Semantic/rules.rst:21
msgid ""
"The order in which you assign each combinational or registered signal has no"
" behavioral impact."
msgstr "您分配每个组合或注册信号的顺序不会对行为产生影响。"
#: ../../source/SpinalHDL/Semantic/rules.rst:23
msgid "For example, both of the following pieces of code are equivalent:"
msgstr "例如，以下两段代码是等效的："
#: ../../source/SpinalHDL/Semantic/rules.rst:32
msgid "This is equivalent to:"
msgstr "这相当于："
#: ../../source/SpinalHDL/Semantic/rules.rst:41
msgid ""
"More generally, when you use the ``:=`` assignment operator, it's like "
"specifying a new rule for the left side signal/register."
msgstr "更一般地说，当您使用 ``:=`` 赋值运算符时，就像为左侧信号/寄存器指定新规则一样。"
#: ../../source/SpinalHDL/Semantic/rules.rst:44
msgid "Last valid assignment wins"
msgstr "最后有效的作业获胜"
#: ../../source/SpinalHDL/Semantic/rules.rst:46
msgid ""
"If a combinational signal or register is assigned multiple times, the last "
"valid one wins."
msgstr "如果组合信号或寄存器被分配多次，则最后一个有效的获胜。"
#: ../../source/SpinalHDL/Semantic/rules.rst:48
msgid "As an example:"
msgstr "举个例子："
#: ../../source/SpinalHDL/Semantic/rules.rst:63
msgid "This will produce the following truth table:"
msgstr "这将产生以下真值表："
#: ../../source/SpinalHDL/Semantic/rules.rst:68
msgid "x"
msgstr "X"
#: ../../source/SpinalHDL/Semantic/rules.rst:69
msgid "y"
msgstr "y"
#: ../../source/SpinalHDL/Semantic/rules.rst:70
msgid "=>"
msgstr "=>"
#: ../../source/SpinalHDL/Semantic/rules.rst:71
msgid "result"
msgstr "结果"
#: ../../source/SpinalHDL/Semantic/rules.rst:72
#: ../../source/SpinalHDL/Semantic/rules.rst:73
#: ../../source/SpinalHDL/Semantic/rules.rst:76
#: ../../source/SpinalHDL/Semantic/rules.rst:81
msgid "False"
msgstr "错误的"
#: ../../source/SpinalHDL/Semantic/rules.rst:75
#: ../../source/SpinalHDL/Semantic/rules.rst:79
msgid "1"
msgstr "1"
#: ../../source/SpinalHDL/Semantic/rules.rst:77
#: ../../source/SpinalHDL/Semantic/rules.rst:80
#: ../../source/SpinalHDL/Semantic/rules.rst:84
#: ../../source/SpinalHDL/Semantic/rules.rst:85
msgid "True"
msgstr "真的"
#: ../../source/SpinalHDL/Semantic/rules.rst:83
msgid "2"
msgstr "2"
#: ../../source/SpinalHDL/Semantic/rules.rst:87
msgid "3"
msgstr "3"
#: ../../source/SpinalHDL/Semantic/rules.rst:91
msgid ""
"Signal and register interactions with Scala (OOP reference + Functions)"
msgstr "与 Scala 的信号和寄存器交互（OOP 参考 + 函数）"
#: ../../source/SpinalHDL/Semantic/rules.rst:93
msgid ""
"In SpinalHDL, each hardware element is modeled by a class instance. This "
"means you can manipulate instances by using their references, such as "
"passing them as arguments to a function."
msgstr "在 SpinalHDL 中，每个硬件元素都由一个类实例建模。这意味着您可以通过使用实例的引用来操作实例，例如将它们作为参数传递给函数。"
#: ../../source/SpinalHDL/Semantic/rules.rst:95
msgid ""
"As an example, the following code implements a register which is incremented"
" when ``inc`` is True and cleared when ``clear`` is True (``clear`` has "
"priority over ``inc``) :"
msgstr ""
"作为示例，以下代码实现了一个寄存器，当 ``inc`` 为 True 时递增，当 ``clear`` 为 True 时清除（``clear`` 优先于 "
"``inc``）："
#: ../../source/SpinalHDL/Semantic/rules.rst:109
msgid ""
"You can implement exactly the same functionality by mixing the previous "
"example with a function that assigns to ``counter``:"
msgstr "您可以通过将前面的示例与分配给“counter”的函数混合来实现完全相同的功能："
#: ../../source/SpinalHDL/Semantic/rules.rst:127
msgid "You can also integrate the conditional check inside the function:"
msgstr "您还可以将条件检查集成到函数内："
#: ../../source/SpinalHDL/Semantic/rules.rst:143
msgid "And also specify what should be assigned to the function:"
msgstr "并指定应分配给函数的内容："
#: ../../source/SpinalHDL/Semantic/rules.rst:159
msgid ""
"All of the previous examples are strictly equivalent both in their generated"
" RTL and also in the SpinalHDL compiler's perspective. This is because "
"SpinalHDL only cares about the Scala runtime and the objects instantiated "
"there, it doesn't care about the Scala syntax itself."
msgstr ""
"前面的所有示例在生成的 RTL 中以及从 SpinalHDL 编译器的角度来看都是严格等效的。这是因为 SpinalHDL 只关心 Scala "
"运行时和在那里实例化的对象，它不关心 Scala 语法本身。"
#: ../../source/SpinalHDL/Semantic/rules.rst:162
msgid ""
"In other words, from a generated RTL generation / SpinalHDL perspective, "
"when you use functions in Scala which generate hardware, it is like the "
"function was inlined. This is also true case for Scala loops, as they will "
"appear in unrolled form in the generated RTL."
msgstr ""
"换句话说，从生成的 RTL 生成/SpinalHDL 的角度来看，当您使用 Scala 中生成硬件的函数时，就像该函数被内联一样。 Scala "
"循环也是如此，因为它们将以展开的形式出现在生成的 RTL 中。"
