
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=utf-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Libraries/fsm.rst:7
msgid "State machine"
msgstr "状态机"
#: ../../source/SpinalHDL/Libraries/fsm.rst:10
msgid "Introduction"
msgstr "介绍"
#: ../../source/SpinalHDL/Libraries/fsm.rst:12
msgid ""
"In SpinalHDL you can define your state machine like in VHDL/Verilog, by "
"using enumerations and switch/case statements. But in SpinalHDL you can also"
" use a dedicated syntax."
msgstr ""
"在 SpinalHDL 中，您可以像在 VHDL/Verilog 中一样，通过使用枚举和 switch/case 语句来定义状态机。但在 "
"SpinalHDL 中，您还可以使用专用语法。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:14
msgid "The state machine below is implemented in the following examples:"
msgstr "下面的状态机在以下示例中实现："
#: ../../source/SpinalHDL/Libraries/fsm.rst:20
msgid "Style A:"
msgstr "款式A："
#: ../../source/SpinalHDL/Libraries/fsm.rst:54
msgid "Style B:"
msgstr "款式B："
#: ../../source/SpinalHDL/Libraries/fsm.rst:92
msgid "StateMachine"
msgstr "状态机"
#: ../../source/SpinalHDL/Libraries/fsm.rst:94
msgid "``StateMachine`` is the base class. It manages the logic of the FSM."
msgstr "“StateMachine”是基类。它管理 FSM 的逻辑。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:102
msgid "``StateMachine`` also provides some accessors:"
msgstr "``StateMachine`` 还提供了一些访问器："
#: ../../source/SpinalHDL/Libraries/fsm.rst:108
#: ../../source/SpinalHDL/Libraries/fsm.rst:189
msgid "Name"
msgstr "姓名"
#: ../../source/SpinalHDL/Libraries/fsm.rst:109
msgid "Return"
msgstr "返回"
#: ../../source/SpinalHDL/Libraries/fsm.rst:110
#: ../../source/SpinalHDL/Libraries/fsm.rst:190
msgid "Description"
msgstr "描述"
#: ../../source/SpinalHDL/Libraries/fsm.rst:111
msgid "``isActive(state)``"
msgstr "``isActive（状态）``"
#: ../../source/SpinalHDL/Libraries/fsm.rst:112
#: ../../source/SpinalHDL/Libraries/fsm.rst:115
msgid "``Bool``"
msgstr "``布尔``"
#: ../../source/SpinalHDL/Libraries/fsm.rst:113
msgid "Returns ``True`` when the state machine is in the given state"
msgstr "当状态机处于给定状态时返回“True”"
#: ../../source/SpinalHDL/Libraries/fsm.rst:114
msgid "``isEntering(state)``"
msgstr "``正在进入（状态）``"
#: ../../source/SpinalHDL/Libraries/fsm.rst:116
msgid "Returns ``True`` when the state machine is entering the given state"
msgstr "当状态机进入给定状态时返回“True”"
#: ../../source/SpinalHDL/Libraries/fsm.rst:119
msgid "Entry point"
msgstr "入口点"
#: ../../source/SpinalHDL/Libraries/fsm.rst:121
msgid ""
"A state can be defined as the entry point of the state machine by extending "
"the EntryPoint trait:"
msgstr "通过扩展 EntryPoint 特征，可以将状态定义为状态机的入口点："
#: ../../source/SpinalHDL/Libraries/fsm.rst:127
msgid "Or by using ``setEntry(state)``:"
msgstr "或者使用“setEntry(state)”："
#: ../../source/SpinalHDL/Libraries/fsm.rst:135
msgid "Transitions"
msgstr "过渡"
#: ../../source/SpinalHDL/Libraries/fsm.rst:137
msgid ""
"Transitions are represented by ``goto(nextState)``, which schedules the "
"state machine to be in ``nextState`` the next cycle."
msgstr "转换由“goto(nextState)”表示，它安排状态机在下一个周期处于“nextState”。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:138
msgid ""
"``exit()`` schedules the state machine to be in the boot state the next "
"cycle (or, in ``StateFsm``, to exit the current nested state machine)."
msgstr "``exit()`` 安排状态机在下一个周期处于启动状态（或者，在 ``StateFsm`` 中，退出当前的嵌套状态机）。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:140
msgid ""
"These two functions can be used inside state definitions (see below) or "
"using ``always { yourStatements }``, which always applies "
"``yourStatements``, with a priority over states."
msgstr ""
"这两个函数可以在状态定义内部使用（见下文）或使用“always { yourStatements "
"}”，它总是应用“yourStatements”，优先于状态。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:144
msgid "State encoding"
msgstr "状态编码"
#: ../../source/SpinalHDL/Libraries/fsm.rst:146
msgid ""
"By default the FSM state vector will be encoded using the native encoding of"
" the language/tools the RTL is generated for (Verilog or VHDL). This default"
" can be overriden by using the ``setEncoding(...)`` method which either "
"takes a ``SpinalEnumEncoding`` or varargs of type ``(State, BigInt)`` for a "
"custom encoding."
msgstr ""
"默认情况下，FSM 状态向量将使用生成 RTL 的语言/工具（Verilog 或 "
"VHDL）的本机编码进行编码。可以使用“setEncoding(...)”方法覆盖此默认值，该方法采用“SpinalEnumEncoding”或“(State,"
" BigInt)”类型的可变参数进行自定义编码。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:150
msgid "Using a ``SpinalEnumEncoding``"
msgstr "使用“SpinalEnumEncoding”"
#: ../../source/SpinalHDL/Libraries/fsm.rst:159
msgid "Using a custom encoding"
msgstr "使用自定义编码"
#: ../../source/SpinalHDL/Libraries/fsm.rst:169
msgid ""
"When using the ``graySequential`` enum encoding, no check is done to verify "
"that the FSM transitions only produce single-bit changes in the state "
"vector. The encoding is done according to the order of state definitions and"
" the designer must ensure that only valid transitions are done if needed."
msgstr ""
"当使用“graySequential”枚举编码时，不会进行任何检查来验证 FSM "
"转换仅在状态向量中产生单位变化。编码是根据状态定义的顺序完成的，设计者必须确保仅在需要时进行有效的转换。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:174
msgid "States"
msgstr "状态"
#: ../../source/SpinalHDL/Libraries/fsm.rst:176
msgid "Multiple kinds of states can be used:"
msgstr "可以使用多种状态："
#: ../../source/SpinalHDL/Libraries/fsm.rst:178
msgid "``State`` (the base one)"
msgstr "“状态”（基础状态）"
#: ../../source/SpinalHDL/Libraries/fsm.rst:179
msgid "``StateDelay``"
msgstr "``状态延迟``"
#: ../../source/SpinalHDL/Libraries/fsm.rst:180
msgid "``StateFsm``"
msgstr "``国家自由主义``"
#: ../../source/SpinalHDL/Libraries/fsm.rst:181
msgid "``StateParallelFsm``"
msgstr "``状态并行Fsm``"
#: ../../source/SpinalHDL/Libraries/fsm.rst:183
msgid ""
"Each of them provides the following functions to define the logic associated"
" to them:"
msgstr "它们每个都提供以下函数来定义与其关联的逻辑："
#: ../../source/SpinalHDL/Libraries/fsm.rst:196
msgid ""
"``yourStatements`` is applied when the state machine is not in ``state`` and"
" will be in ``state`` the next cycle"
msgstr "当状态机不处于“state”并且在下一个周期将处于“state”时，应用“yourStatements”"
#: ../../source/SpinalHDL/Libraries/fsm.rst:202
msgid ""
"``yourStatements`` is applied when the state machine is in ``state`` and "
"will be in another state the next cycle"
msgstr "当状态机处于“state”时应用“yourStatements”，并且在下一个周期将处于另一个状态"
#: ../../source/SpinalHDL/Libraries/fsm.rst:208
msgid "``yourStatements`` is applied when the state machine is in ``state``"
msgstr "当状态机处于“state”时应用“yourStatements”"
#: ../../source/SpinalHDL/Libraries/fsm.rst:214
msgid ""
"``yourStatements`` is executed when the state machine will be in ``state`` "
"the next cycle (even if it is already in it)"
msgstr "当状态机在下一个周期处于“state”时（即使它已经在其中），“yourStatements”被执行"
#: ../../source/SpinalHDL/Libraries/fsm.rst:216
msgid "``state.`` is implicit in a ``new State`` block:"
msgstr "“state.” 隐含在“new State” 块中："
#: ../../source/SpinalHDL/Libraries/fsm.rst:236
msgid "StateDelay"
msgstr "状态延迟"
#: ../../source/SpinalHDL/Libraries/fsm.rst:238
msgid ""
"``StateDelay`` allows to create a state which waits for a fixed number of "
"cycles before executing statments in ``whenCompleted {...}``. The preferred "
"way to use it is:"
msgstr ""
"“StateDelay” 允许创建一个状态，该状态在执行“whenCompleted {...}” 中的语句之前等待固定数量的周期。首选的使用方式是："
#: ../../source/SpinalHDL/Libraries/fsm.rst:248
msgid "It can also be written in one line:"
msgstr "也可以写成一行："
#: ../../source/SpinalHDL/Libraries/fsm.rst:255
msgid "StateFsm"
msgstr "国家FSM"
#: ../../source/SpinalHDL/Libraries/fsm.rst:257
msgid ""
"``StateFsm`` allow to describe a state containing a nested state machine. "
"When the nested state machine is done (exited), statments in ``whenCompleted"
" { ... }`` are executed."
msgstr ""
"“StateFsm” 允许描述包含嵌套状态机的状态。当嵌套状态机完成（退出）时，执行“whenCompleted { ... }”中的语句。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:259
msgid "There is an example of StateFsm definition :"
msgstr "有一个 StateFsm 定义的示例："
#: ../../source/SpinalHDL/Libraries/fsm.rst:290
msgid ""
"In the example above, ``exit()`` makes the state machine jump to the boot "
"state (a internal hidden state). This notifies ``StateFsm`` about the "
"completion of the inner state machine."
msgstr "在上面的示例中，“exit()”使状态机跳转到引导状态（内部隐藏状态）。这通知“StateFsm”有关内部状态机的完成。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:293
msgid "StateParallelFsm"
msgstr "状态并行FSM"
#: ../../source/SpinalHDL/Libraries/fsm.rst:295
msgid ""
"``StateParallelFsm`` allows to handle multiple nested state machines. When "
"all nested state machine are done, statments in ``whenCompleted { ... }`` "
"are executed."
msgstr ""
"“StateParallelFsm”允许处理多个嵌套状态机。当所有嵌套状态机完成时，执行“whenCompleted { ... }”中的语句。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:297
#: ../../source/SpinalHDL/Libraries/fsm.rst:322
msgid "Example:"
msgstr "例子："
#: ../../source/SpinalHDL/Libraries/fsm.rst:308
msgid "Notes about the entry state"
msgstr "关于进入状态的注释"
#: ../../source/SpinalHDL/Libraries/fsm.rst:310
msgid ""
"The way the entry state has been defined above makes it so that between the "
"reset and the first clock sampling, the state machine is in a boot state. It"
" is only after the first clock sampling that the defined entry state becomes"
" active. This allows to properly enter the entry state (applying statements "
"in ``onEntry``), and allows nested state machines."
msgstr ""
"上面定义进入状态的方式使得在复位和第一次时钟采样之间，状态机处于引导状态。只有在第一次时钟采样之后，定义的进入状态才会变为活动状态。这允许正确进入进入状态（在“onEntry”中应用语句），并允许嵌套状态机。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:312
msgid ""
"While it is usefull, it is also possible to bypass that feature and directly"
" having a state machine booting into a user state."
msgstr "虽然它很有用，但也可以绕过该功能并直接让状态机启动到用户状态。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:314
msgid ""
"To do so, use `makeInstantEntry()` instead of defining a ``new State``. This"
" function returns the boot state, active directly after reset."
msgstr "为此，请使用“makeInstantEntry()”而不是定义“new State”。该函数返回启动状态，复位后直接激活。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:317
msgid ""
"The ``onEntry`` of that state will only be called when it transitions from "
"another state to this state and not during boot."
msgstr "该状态的“onEntry”仅在从另一个状态转换到此状态时才会被调用，而不是在引导期间。"
#: ../../source/SpinalHDL/Libraries/fsm.rst:320
msgid "During simulation, the boot state is always named ``BOOT``."
msgstr "在仿真过程中，启动状态始终命名为“BOOT”。"
