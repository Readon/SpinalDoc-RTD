
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=utf-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Libraries/fiber.rst:7
msgid "Fiber framework"
msgstr "纤维骨架"
#: ../../source/SpinalHDL/Libraries/fiber.rst:9
msgid "Currently in developpement."
msgstr "目前正在开发中。"
#: ../../source/SpinalHDL/Libraries/fiber.rst:11
msgid ""
"The Fiber to run the hardware elaboration in a out of order manner, a bit "
"similarly to Makefile, where you can define rules and dependencies which "
"will then be solved when you run a make command. It is very similar to the "
"Scala Future feature."
msgstr ""
"Fiber 以无序的方式运行硬件精化，有点类似于 Makefile，您可以在其中定义规则和依赖关系，然后在运行 make "
"命令时解决这些规则和依赖关系。它与 Scala Future 功能非常相似。"
#: ../../source/SpinalHDL/Libraries/fiber.rst:13
msgid ""
"Such framework complexify simple things but provide some strong feature for "
"complex cases :"
msgstr "这样的框架使简单的事情变得复杂，但为复杂的情况提供了一些强大的功能："
#: ../../source/SpinalHDL/Libraries/fiber.rst:15
msgid ""
"You can define things before even knowing all their requirements, ex : "
"instanciating a interruption controller, before knowing how many lines of "
"interrupt you need"
msgstr "您甚至可以在知道所有要求之前就定义事物，例如：在知道需要多少行中断之前实例化中断控制器"
#: ../../source/SpinalHDL/Libraries/fiber.rst:16
msgid ""
"Abstract/lazy/partial SoC architecture definition allowing the creation of "
"SoC template for further specialisations"
msgstr "抽象/惰性/部分 SoC 架构定义允许创建 SoC 模板以实现进一步专业化"
#: ../../source/SpinalHDL/Libraries/fiber.rst:17
msgid ""
"Automatic requirements negotiation between multiple agents in a "
"decentralized way, ex : between masters and slaves of a memory bus"
msgstr "以分散方式在多个代理之间自动进行需求协商，例如：内存总线的主设备和从设备之间"
#: ../../source/SpinalHDL/Libraries/fiber.rst:19
msgid "The framework is mainly composed of :"
msgstr "该框架主要由以下部分组成："
#: ../../source/SpinalHDL/Libraries/fiber.rst:21
msgid "Handle[T], which can be used later to store a value of type T."
msgstr "Handle[T]，稍后可用于存储 T 类型的值。"
#: ../../source/SpinalHDL/Libraries/fiber.rst:22
msgid ""
"handle.load which allow to set the value of a handle (will reschedule all "
"tasks waiting on it)"
msgstr "handle.load 允许设置句柄的值（将重新安排等待它的所有任务）"
#: ../../source/SpinalHDL/Libraries/fiber.rst:23
msgid ""
"handle.get, which return the value of the given handle. Will block the task "
"execution if that handle isn't loaded yet"
msgstr "handle.get，返回给定句柄的值。如果尚未加载该句柄，将阻止任务执行"
#: ../../source/SpinalHDL/Libraries/fiber.rst:24
msgid ""
"Handle{ code }, which fork a new task which will execute the given code. The"
" result of that code will be loaded into the Handle"
msgstr "Handle{ code }，它派生一个新任务来执行给定的代码。该代码的结果将被加载到句柄中"
#: ../../source/SpinalHDL/Libraries/fiber.rst:25
msgid ""
"soon(handle), which allow the current task to announce that soon it will "
"load that handle with a value (used to track which handle will"
msgstr "oon(handle)，它允许当前任务宣布很快它将加载该句柄一个值（用于跟踪哪个句柄将"
#: ../../source/SpinalHDL/Libraries/fiber.rst:28
msgid ""
"Warning, this is realy not usual RTL description and aim large system "
"generation. It is currently used as toplevel integration tool in SaxonSoC."
msgstr "警告，这确实不是通常的 RTL 描述，其目标是大型系统生成。它目前在 SaxonSoC 中用作顶级集成工具。"
#: ../../source/SpinalHDL/Libraries/fiber.rst:31
msgid "Simple dummy example"
msgstr "简单的虚拟示例"
#: ../../source/SpinalHDL/Libraries/fiber.rst:33
msgid "There is a simple example :"
msgstr "有一个简单的例子："
#: ../../source/SpinalHDL/Libraries/fiber.rst:56
msgid "Its runtime will be :"
msgstr "它的运行时间将是："
#: ../../source/SpinalHDL/Libraries/fiber.rst:58
msgid "create a and b"
msgstr "创建a和b"
#: ../../source/SpinalHDL/Libraries/fiber.rst:59
msgid "fork the calculator task, but is blocked when executing a.get"
msgstr "fork 计算器任务，但在执行 a.get 时被阻止"
#: ../../source/SpinalHDL/Libraries/fiber.rst:60
msgid "fork the printer task, but is blocked when executing calculator.get"
msgstr "fork 打印机任务，但在执行calculator.get 时被阻止"
#: ../../source/SpinalHDL/Libraries/fiber.rst:61
msgid ""
"load a and b, which reschedule the calculator task (as it was waiting on a)"
msgstr "加载 a 和 b，这会重新安排计算器任务（因为它正在等待 a）"
#: ../../source/SpinalHDL/Libraries/fiber.rst:62
msgid ""
"calculator do its a + b sum, and load its Handle with that result, which "
"reschedule the printer task"
msgstr "计算器执行 a + b 求和，并使用该结果加载其句柄，从而重新安排打印机任务"
#: ../../source/SpinalHDL/Libraries/fiber.rst:63
msgid "printer task print its stuff"
msgstr "打印机任务打印它的东西"
#: ../../source/SpinalHDL/Libraries/fiber.rst:64
msgid "everything done"
msgstr "一切都完成了"
#: ../../source/SpinalHDL/Libraries/fiber.rst:67
msgid ""
"So, the main point of that example is to show that we kind of overcome the "
"sequential execution of things, as a and b are loaded after the definition "
"of the calculator."
msgstr "因此，该示例的要点是表明我们在某种程度上克服了事物的顺序执行，因为 a 和 b 在计算器定义之后加载。"
#: ../../source/SpinalHDL/Libraries/fiber.rst:71
msgid "Handle[T]"
msgstr "手柄[T]"
#: ../../source/SpinalHDL/Libraries/fiber.rst:73
msgid ""
"Handle[T] are a bit like scala's Future[T], they allow to talk about "
"something before it is even existing, and wait on it."
msgstr "Handle[T] 有点像 scala 的 Future[T]，它们允许在某件事存在之前就谈论它，并等待它。"
#: ../../source/SpinalHDL/Libraries/fiber.rst:84
msgid "soon(handle)"
msgstr "很快（处理）"
#: ../../source/SpinalHDL/Libraries/fiber.rst:86
msgid ""
"In order to maintain a proper graph of dependencies between tasks and "
"Handle, a task can specify in advance that it will load a given handle. This"
" is very usefull in case of a generation starvation/deadlock for SpinalHDL "
"to report accuratly where is the issue."
msgstr ""
"为了维护任务和句柄之间正确的依赖关系图，任务可以提前指定它将加载给定的句柄。这在发生生成饥饿/死锁的情况下非常有用，以便 SpinalHDL "
"准确报告问题所在。"
